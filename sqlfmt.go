package tdconv

import (
	"fmt"
	"io"
	"strings"
)

// SQLFormatter is a formatter to output the table definision as SQL.
type SQLFormatter struct {
	formatter
}

// NewSQLFormatter creates a new SQLFormatter.
// You can change some parameters of the SQLFormatter with SQLFormatOption.
func NewSQLFormatter(options ...SQLFormatOption) (*SQLFormatter, error) {
	f := SQLFormatter{}
	f.setHeader(func(w io.Writer, _ *TableSet) {
		fmt.Fprint(w,
			"# This file generated by tdconv. DO NOT EDIT.\n"+
				"# See more details at https://github.com/takuoki/tdconv.\n")
	})
	for _, opt := range options {
		err := opt(&f)
		if err != nil {
			return nil, err
		}
	}
	return &f, nil
}

// SQLFormatOption changes some parameters of the SQLFormatter.
type SQLFormatOption func(*SQLFormatter) error

// SQLHeader changes the header.
func SQLHeader(fc func(w io.Writer, tableSet *TableSet)) SQLFormatOption {
	return func(f *SQLFormatter) error {
		f.setHeader(fc)
		return nil
	}
}

// SQLTableHeader changes the header of each table.
func SQLTableHeader(fc func(w io.Writer, table *Table)) SQLFormatOption {
	return func(f *SQLFormatter) error {
		f.setTableHeader(fc)
		return nil
	}
}

// SQLTableFooter changes the footer of each table.
func SQLTableFooter(fc func(w io.Writer, table *Table)) SQLFormatOption {
	return func(f *SQLFormatter) error {
		f.setTableFooter(fc)
		return nil
	}
}

// SQLFooter changes the footer.
func SQLFooter(fc func(w io.Writer, tableSet *TableSet)) SQLFormatOption {
	return func(f *SQLFormatter) error {
		f.setFooter(fc)
		return nil
	}
}

// Extension returns the extension of SQL file.
func (f *SQLFormatter) Extension() string {
	return "sql"
}

// Fprint outputs the table definision as SQL.
func (f *SQLFormatter) Fprint(w io.Writer, t *Table) {

	if f == nil || t == nil {
		return
	}

	fmt.Fprintf(w, "DROP TABLE IF EXISTS %[1]s;\nCREATE TABLE `%[1]s` (\n", t.Name)

	for i, c := range t.Columns {
		es := make([]string, 0, 6)
		es = append(es, "    `"+c.Name+"`")
		es = append(es, c.Type)
		if c.NotNull {
			es = append(es, "NOT NULL")
		}
		if c.Option != "" {
			es = append(es, c.Option)
		}
		if c.Unique {
			es = append(es, "UNIQUE")
		}
		if c.Comment != "" {
			es = append(es, "COMMENT '"+c.Comment+"'")
		}
		fmt.Fprint(w, strings.Join(es, " "))
		if i < len(t.Columns)-1 {
			fmt.Fprint(w, ",\n")
		}
	}

	if len(t.PKeyColumns) > 0 {
		fmt.Fprintf(w, ",\n    PRIMARY KEY (%s)", strings.Join(t.PKeyColumns, ", "))
	}
	for _, k := range t.UniqueKeys {
		fmt.Fprintf(w, ",\n    UNIQUE KEY `%s` (%s)", k.Name, strings.Join(k.Columns, ", "))
	}
	for _, k := range t.IndexKeys {
		fmt.Fprintf(w, ",\n    INDEX `%s` (%s)", k.Name, strings.Join(k.Columns, ", "))
	}

	fmt.Fprintln(w, "\n);")
}
